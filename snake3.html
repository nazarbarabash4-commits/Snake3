<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>Snake 3</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #020617;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    .wrap {
      display: grid;
      grid-template-columns: 260px 820px;
      gap: 20px;
      width: 1120px;
      max-width: 100%;
      padding: 16px;
    }

    .panel {
      background: #020617;
      border-radius: 20px;
      padding: 20px 18px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.6);
    }

    h1 {
      margin: 0 0 12px;
      font-size: 22px;
    }

    .perk {
      background: #020617;
      border-radius: 10px;
      padding: 8px 10px;
      margin-bottom: 6px;
      border: 1px solid #111827;
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }

    .btn {
      margin-top: 10px;
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: #2563eb;
      color: #fff;
      font-weight: 500;
      font-size: 14px;
    }

    .btn.secondary {
      background: #111827;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .stats {
      margin-top: 10px;
      font-size: 13px;
      line-height: 1.4;
    }

    .canvas-wrap {
      background: #020617;
      border-radius: 24px;
      box-shadow: 0 22px 50px rgba(0,0,0,0.7);
      padding: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      border-radius: 18px;
      background: #020617;
      display: block;
    }

    .hint {
      margin-top: 10px;
      font-size: 12px;
      color: #9ca3af;
      line-height: 1.4;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>Snake 3</h1>

    <div class="perk">
      <span>üêç –§–∞–Ω—Ç–æ–º</span><span>[Q]</span>
    </div>
    <div class="perk">
      <span>‚ö° –¢—É—Ä–±–æ</span><span>[E]</span>
    </div>

    <button class="btn" id="startBtn">–°—Ç–∞—Ä—Ç</button>
    <button class="btn secondary" id="restartBtn">–†–µ—Å—Ç–∞—Ä—Ç</button>

    <div class="stats">
      <div>–†–∞—Ö—É–Ω–æ–∫: <span id="score">0</span></div>
      <div>–©–∏—Ç: <span id="shield">1</span></div>
      <div>–°—Ç–∞–Ω: <span id="state">–û—á—ñ–∫—É—î —Å—Ç–∞—Ä—Ç—É</span></div>
      <div>–ï—Ñ–µ–∫—Ç–∏: <span id="effects">‚Äî</span></div>
    </div>

    <div class="hint">
      –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è:<br>
      ‚Ä¢ A / D ‚Äì –ø–æ–≤–æ—Ä–æ—Ç<br>
      ‚Ä¢ E ‚Äì —Ç—Ä–∏–º–∞–π –¥–ª—è –ø—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è<br>
      ‚Ä¢ Q ‚Äì —Ä–µ–∂–∏–º —Ñ–∞–Ω—Ç–æ–º–∞ (2 —Å, –∫—É–ª–¥–∞—É–Ω)<br>
      ‚Ä¢ P ‚Äì –ø–∞—É–∑–∞<br><br>
      –Ø–±–ª—É–∫–æ: –æ–¥–Ω–µ, –ø—Ä–æ—Å—Ç–µ ‚Äì –¥–∞—î +1 –æ—á–∫–æ —ñ —Ä–æ—Å—Ç–µ –∑–º—ñ–π–∫–∞.<br>
      –ó—ñ –∑—Ä–æ—Å—Ç–∞–Ω–Ω—è–º —Ä–∞—Ö—É–Ω–∫—É –∑ º—è–≤–ª—è—é—Ç—å—Å—è: —á–µ—Ä–≤–æ–Ω—ñ –≤–æ—Ä–æ–≥–∏, —Å–Ω–∞–π–ø–µ—Ä, –º—ñ–Ω–∏, —à–≤–∏–¥–∫—ñ –≤–æ—Ä–æ–≥–∏.
    </div>
  </div>

  <div class="canvas-wrap">
    <canvas id="game" width="800" height="560"></canvas>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');
const scoreEl = document.getElementById('score');
const shieldEl = document.getElementById('shield');
const stateEl = document.getElementById('state');
const effectsEl = document.getElementById('effects');

const keys = {};
let game = null;
let lastTime = 0;

// --------- –ö–ª–∞—Å–∏ ---------
class Snake {
  constructor(x, y) {
    this.pos = { x, y };
    this.angle = 0;
    this.baseSpeed = 2.4;
    this.speed = this.baseSpeed;
    this.radius = 10;
    this.segments = [];
    this.length = 30;

    this.ghost = false;
    this.ghostCooldown = 0;
    this.ghostDurationMs = 2000;

    this.shield = 1;
  }

  update(dt) {
    if (this.ghostCooldown > 0) this.ghostCooldown -= dt;
    if (this.ghostCooldown < 0) this.ghostCooldown = 0;

    this.pos.x += Math.cos(this.angle) * this.speed;
    this.pos.y += Math.sin(this.angle) * this.speed;

    this.segments.unshift({ x: this.pos.x, y: this.pos.y });
    if (this.segments.length > this.length) {
      this.segments.pop();
    }
  }

  grow(amount = 10) {
    this.length += amount;
  }

  draw() {
    // –≥–ª–∞–¥–∫–µ —Ç—ñ–ª–æ
    ctx.lineWidth = this.radius * 2;
    ctx.strokeStyle = this.ghost ? '#a855f7' : '#22c55e';
    ctx.lineCap = 'round';

    ctx.beginPath();
    for (let i = 0; i < this.segments.length; i++) {
      const s = this.segments[i];
      if (i === 0) ctx.moveTo(s.x, s.y);
      else ctx.lineTo(s.x, s.y);
    }
    ctx.stroke();

    // –≥–æ–ª–æ–≤–∞
    ctx.save();
    ctx.shadowColor = this.ghost ? '#a855f7' : '#4ade80';
    ctx.shadowBlur = 12;
    ctx.fillStyle = this.ghost ? '#a855f7' : '#22c55e';
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, this.radius + 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // –æ—á—ñ
    const eyeAngle = this.angle;
    const ex = Math.cos(eyeAngle) * 6;
    const ey = Math.sin(eyeAngle) * 6;

    ctx.fillStyle = '#0f172a';
    ctx.beginPath();
    ctx.arc(this.pos.x + ex - 3, this.pos.y + ey, 2.5, 0, Math.PI * 2);
    ctx.arc(this.pos.x + ex + 3, this.pos.y + ey, 2.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Enemy {
  constructor(x, y, speed = 1.6, radius = 14, color = '#ef4444', fast = false) {
    this.pos = { x, y };
    this.baseSpeed = speed;
    this.radius = radius;
    this.color = color;
    this.fast = fast;
  }

  update(player, slowFactor) {
    const a = Math.atan2(player.pos.y - this.pos.y, player.pos.x - this.pos.x);
    const sp = this.baseSpeed * slowFactor;
    this.pos.x += Math.cos(a) * sp;
    this.pos.y += Math.sin(a) * sp;
  }

  draw() {
    const pulse = Math.sin(performance.now() / 200) * 2;
    const grad = ctx.createRadialGradient(
      this.pos.x, this.pos.y, 4,
      this.pos.x, this.pos.y, this.radius + 4
    );
    grad.addColorStop(0, '#fecaca');
    grad.addColorStop(1, this.fast ? '#b91c1c' : '#991b1b');

    ctx.fillStyle = grad;
    ctx.save();
    ctx.shadowColor = this.fast ? '#fb7185' : '#ef4444';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, this.radius + pulse, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.strokeStyle = 'rgba(248,113,113,0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, this.radius + 6, 0, Math.PI * 2);
    ctx.stroke();
  }
}

class Sniper {
  constructor(x, y) {
    this.pos = { x, y };
    this.radius = 14;
    this.cooldown = 0;
    this.cooldownMax = 120;
    this.angle = 0;
  }

  update(player) {
    this.cooldown--;
    this.angle = Math.atan2(player.pos.y - this.pos.y, player.pos.x - this.pos.x);
    if (this.cooldown <= 0) {
      game.bullets.push(new Bullet(this.pos.x, this.pos.y, player));
      this.cooldown = this.cooldownMax;
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.pos.x, this.pos.y);

    ctx.fillStyle = '#111827';
    ctx.beginPath();
    ctx.arc(0, 0, this.radius + 4, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = '#4c1d95';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
    ctx.stroke();

    ctx.rotate(this.angle);
    ctx.fillStyle = '#a855f7';
    if (ctx.roundRect) {
      ctx.beginPath();
      ctx.roundRect(0, -3, this.radius + 10, 6, 3);
      ctx.fill();
    } else {
      ctx.fillRect(0, -3, this.radius + 10, 6);
    }

    ctx.rotate(-this.angle);
    ctx.fillStyle = '#c4b5fd';
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

class Bullet {
  constructor(x, y, target) {
    this.pos = { x, y };
    const a = Math.atan2(target.pos.y - y, target.pos.x - x);
    this.dir = { x: Math.cos(a), y: Math.sin(a) };
    this.baseSpeed = 4;
    this.radius = 4;
    this.dead = false;
    this.angle = a;
  }

  update(slowFactor) {
    const sp = this.baseSpeed * slowFactor;
    this.pos.x += this.dir.x * sp;
    this.pos.y += this.dir.y * sp;
    if (
      this.pos.x < -20 || this.pos.x > canvas.width + 20 ||
      this.pos.y < -20 || this.pos.y > canvas.height + 20
    ) {
      this.dead = true;
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.pos.x, this.pos.y);
    ctx.rotate(this.angle);

    const grad = ctx.createLinearGradient(-14, 0, 4, 0);
    grad.addColorStop(0, 'rgba(129,140,248,0)');
    grad.addColorStop(1, '#ddd6fe');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(-14, -3);
    ctx.lineTo(4, -1.5);
    ctx.lineTo(4, 1.5);
    ctx.lineTo(-14, 3);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#e5e7eb';
    ctx.beginPath();
    ctx.arc(4, 0, this.radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

class Mine {
  constructor(x, y) {
    this.pos = { x, y };
    this.radius = 14;
    this.explosionRadius = 52;
    this.dead = false;
  }

  update(player) {
    if (!player.ghost) {
      if (dist(player.pos, this.pos) < this.explosionRadius) {
        this.dead = true;
        handleHit('–º—ñ–Ω–∞');
      }
    }
  }

  draw() {
    const x = this.pos.x;
    const y = this.pos.y;

    // --- –ú º—è–∫–∞ –∑–æ–Ω–∞ –≤–∏–±—É—Ö—É ---
    ctx.strokeStyle = 'rgba(248,250,252,0.05)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, this.explosionRadius, 0, Math.PI * 2);
    ctx.stroke();

    // --- –ù–µ–æ–Ω–æ–≤–∏–π glow –Ω–∞–≤–∫–æ–ª–æ –∫–æ—Ä–ø—É—Å—É –º—ñ–Ω–∏ ---
    ctx.save();
    ctx.shadowColor = '#facc15';  // –∂–æ–≤—Ç–∏–π glow, —è–∫ —É —è–±–ª—É–∫–∞
    ctx.shadowBlur = 18;
    ctx.fillStyle = '#eab308';
    ctx.beginPath();
    ctx.arc(x, y, this.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // --- –í–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π –≥—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π –¥–∏—Å–∫ ---
    const grad = ctx.createRadialGradient(
      x - 2, y - 2, 2,
      x, y, this.radius + 3
    );
    grad.addColorStop(0, '#fef9c3');
    grad.addColorStop(1, '#1f2937');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, this.radius - 1, 0, Math.PI * 2);
    ctx.fill();

    // --- –¢–æ–Ω–∫–µ –∂–æ–≤—Ç–µ –∫—ñ–ª—å—Ü–µ –ø–æ –∫—Ä–∞—é ---
    ctx.strokeStyle = 'rgba(250,204,21,0.9)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, this.radius - 3, 0, Math.PI * 2);
    ctx.stroke();

    // --- –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞ —Ç–µ–º–Ω–∞ —Ç–æ—á–∫–∞ ---
    ctx.fillStyle = '#020617';
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Food {
  constructor(x, y) {
    this.pos = { x, y };
    this.radius = 8;
  }

  draw() {
    const x = this.pos.x;
    const y = this.pos.y;

    // --- –ù–ï–û–ù–û–í–ï –°–í–Ü–¢–Ü–ù–ù–Ø ---
    ctx.save();
    ctx.shadowColor = '#facc15';
    ctx.shadowBlur = 15;
    ctx.fillStyle = '#eab308';
    ctx.beginPath();
    ctx.arc(x, y, this.radius + 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // --- –ì–õ–ê–î–ö–ò–ô –ì–†–ê–î–Ü–Ñ–ù–¢ –Ø–ë–õ–£–ö–ê ---
    const grad = ctx.createRadialGradient(
      x - 3, y - 3, 2,
      x, y, this.radius + 2
    );
    grad.addColorStop(0, '#fef9c3');
    grad.addColorStop(1, '#eab308');

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, this.radius + 1, 0, Math.PI * 2);
    ctx.fill();

    // --- –ú–Ü–ù–Ü-–õ–ò–°–¢–û–ö –ù–ê–í–ï–†–•–£ ---
    ctx.fillStyle = '#16a34a';
    ctx.beginPath();
    ctx.ellipse(
      x - 3,
      y - this.radius,
      3, 5,
      -0.4, 0, Math.PI * 2
    );
    ctx.fill();
  }
}

// --------- –•–µ–ª–ø–µ—Ä–∏ ---------
function dist(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.hypot(dx, dy);
}

function circleCollide(p1, r1, p2, r2) {
  return dist(p1, p2) < r1 + r2;
}

function randomPosAwayFrom(playerPos, minDist = 80) {
  let x, y, tries = 0;
  do {
    x = 40 + Math.random() * (canvas.width - 80);
    y = 40 + Math.random() * (canvas.height - 80);
    tries++;
  } while (tries < 50 && dist(playerPos, {x,y}) < minDist);
  return {x, y};
}

// --------- –Ü–≥—Ä–æ–≤–∏–π —Å—Ç–∞–Ω ---------
function resetGame() {
  const player = new Snake(canvas.width / 2, canvas.height / 2 + 40);
  const foodPos = randomPosAwayFrom(player.pos, 120);

  game = {
    player,
    enemies: [],
    snipers: [],
    mines: [],
    bullets: [],
    food: new Food(foodPos.x, foodPos.y),
    score: 0,
    running: false,
    gameOver: false,
    paused: false,     // ‚Üê —Å—Ç–∞–Ω –ø–∞—É–∑–∏
  };

  updateUI();
  draw(0);
}

function startGame() {
  if (!game) resetGame();
  if (game.gameOver) resetGame();
  game.running = true;
  game.gameOver = false;
  game.paused = false;
  stateEl.textContent = '–£ –ø—Ä–æ—Ü–µ—Å—ñ';
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

// –±–∞–∑–æ–≤—ñ –≤–æ—Ä–æ–≥–∏ ‚Äì –ø–ª–∞–≤–Ω–∏–π —Ä—ñ—Å—Ç
function desiredBaseEnemies(score) {
  if (score < 4) return 0;
  if (score < 8) return 1;
  if (score < 13) return 2;
  if (score < 19) return 3;
  return 4;
}

function spawnBaseEnemy(player) {
  const pos = randomPosAwayFrom(player.pos, 140);
  return new Enemy(pos.x, pos.y, 1.6, 14, '#ef4444', false);
}

function spawnFastEnemy(player) {
  const pos = randomPosAwayFrom(player.pos, 140);
  return new Enemy(pos.x, pos.y, 2.6, 9, '#ef4444', true);
}

function ensureBaseEnemies() {
  const desired = desiredBaseEnemies(game.score);
  const currentBase = game.enemies.filter(e => !e.fast);
  const diff = desired - currentBase.length;

  if (diff > 0) {
    for (let i = 0; i < diff; i++) {
      game.enemies.push(spawnBaseEnemy(game.player));
    }
  } else if (diff < 0) {
    for (let i = 0; i < Math.abs(diff); i++) {
      const idx = game.enemies.findIndex(e => !e.fast);
      if (idx >= 0) game.enemies.splice(idx, 1);
    }
  }
}

function spawnFood() {
  const pos = randomPosAwayFrom(game.player.pos, 100);
  game.food = new Food(pos.x, pos.y);
}

// --------- Update / Draw ---------
function loop(timestamp) {
  if (!game || !game.running) return;
  const dtMs = timestamp - lastTime;
  lastTime = timestamp;
  const dt = dtMs / 16.666;

  if (!game.paused) {
    update(dt);
  }
  draw(dt);

  if (game.running) requestAnimationFrame(loop);
}

function update(dt) {
  const p = game.player;

  // –ö–µ—Ä—É—î–º–æ –ø–æ –∫–æ–¥—É –∫–ª–∞–≤—ñ—à, –∞ –Ω–µ –ø–æ —Å–∏–º–≤–æ–ª—É
  if (keys['KeyA']) p.angle -= 0.06 * dt;
  if (keys['KeyD']) p.angle += 0.06 * dt;

  const boostFactor = keys['KeyE'] ? 1.8 : 1;
  p.speed = p.baseSpeed * boostFactor;

  if (keys['KeyQ'] && !p.ghost && p.ghostCooldown <= 0) {
    activateGhost();
  }

  p.update(dt);

  const slowFactor = 1;
  game.enemies.forEach(e => e.update(p, slowFactor));
  game.snipers.forEach(s => s.update(p));
  game.mines.forEach(m => m.update(p));
  game.bullets.forEach(b => b.update(slowFactor));

  game.bullets = game.bullets.filter(b => !b.dead);
  game.mines = game.mines.filter(m => !m.dead);

  const margin = 10;
  if (
    p.pos.x < margin || p.pos.x > canvas.width - margin ||
    p.pos.y < margin || p.pos.y > canvas.height - margin
  ) {
    handleHit('—Å—Ç—ñ–Ω–∞');
  }

  if (game.food && circleCollide(p.pos, p.radius, game.food.pos, game.food.radius)) {
    onFoodEat();
    spawnFood();
  }

  if (!p.ghost) {
    for (const e of game.enemies) {
      if (circleCollide(p.pos, p.radius, e.pos, e.radius)) {
        handleHit('–≤–æ—Ä–æ–≥');
        break;
      }
    }
    for (const b of game.bullets) {
      if (circleCollide(p.pos, p.radius, b.pos, b.radius)) {
        b.dead = true;
        handleHit('–∫—É–ª—è');
        break;
      }
    }
  }

  ensureBaseEnemies();
  updateUI();
}

function draw(dt) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const bgGrad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
  bgGrad.addColorStop(0, '#020617');
  bgGrad.addColorStop(1, '#020617');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = '#1e293b';
  ctx.lineWidth = 4;
  ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);

  if (!game) return;

  if (game.food) game.food.draw();
  game.mines.forEach(m => m.draw());
  game.enemies.forEach(e => e.draw());
  game.snipers.forEach(s => s.draw());
  game.bullets.forEach(b => b.draw());

  drawOrbs(game.player, game.score);
  game.player.draw();

  if (game.player.ghost) {
    ctx.fillStyle = 'rgba(88,28,135,0.22)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // –ï–∫—Ä–∞–Ω –ø–∞—É–∑–∏
  if (game.paused && !game.gameOver) {
    ctx.fillStyle = 'rgba(15,23,42,0.65)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#e5e7eb';
    ctx.textAlign = 'center';
    ctx.font = '28px system-ui';
    ctx.fillText('–ü–ê–£–ó–ê', canvas.width / 2, canvas.height / 2 - 10);
    ctx.font = '16px system-ui';
    ctx.fillText('–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å P, —â–æ–± –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏', canvas.width / 2, canvas.height / 2 + 20);
    return;
  }

  if (game.gameOver) {
    ctx.fillStyle = 'rgba(15,23,42,0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#e5e7eb';
    ctx.textAlign = 'center';
    ctx.font = '28px system-ui';
    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 10);
    ctx.font = '16px system-ui';
    ctx.fillText(`–†–∞—Ö—É–Ω–æ–∫: ${game.score}`, canvas.width / 2, canvas.height / 2 + 20);
    ctx.fillText('–ù–∞—Ç–∏—Å–Ω–∏ "–†–µ—Å—Ç–∞—Ä—Ç", —â–æ–± —Å–ø—Ä–æ–±—É–≤–∞—Ç–∏ —â–µ', canvas.width / 2, canvas.height / 2 + 46);
  }
}

// --------- –û—Ä–±–∏ –Ω–∞ —Ç—ñ–ª—ñ ---------
function orbCount(score) {
  return Math.min(score, 6);
}
function getOrbPoints(player, count) {
  if (count <= 0) return [];
  if (player.segments.length < 5) return [];

  const points = [];
  const step = Math.floor(player.segments.length / (count + 1));
  for (let i = 0; i < count; i++) {
    const index = (i + 1) * step;
    if (index < player.segments.length) {
      points.push(player.segments[index]);
    }
  }
  return points;
}
function drawOrbs(player, score) {
  const count = orbCount(score);
  const points = getOrbPoints(player, count);
  if (!points.length) return;

  ctx.save();
  points.forEach((seg, i) => {
    const alpha = 0.3 + i * 0.05;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(seg.x, seg.y, player.radius + 3, 0, Math.PI * 2);
    ctx.fillStyle = '#22c55e';
    ctx.fill();

    ctx.globalAlpha = alpha * 0.6;
    ctx.beginPath();
    ctx.arc(seg.x, seg.y, player.radius + 9, 0, Math.PI * 2);
    ctx.fillStyle = '#4ade80';
    ctx.fill();
  });
  ctx.restore();
  ctx.globalAlpha = 1;
}

// --------- –á–∂–∞ (–ø—Ä–æ—Å—Ç–µ —è–±–ª—É–∫–æ) ---------
function onFoodEat() {
  const p = game.player;
  game.score++;
  p.grow(10);

  // –ø–æ–µ—Ç–∞–ø–Ω–µ —É—Å–∫–ª–∞–¥–Ω–µ–Ω–Ω—è
  if (game.score === 6) {         // –ø–µ—Ä—à–∏–π —Å–Ω–∞–π–ø–µ—Ä
    const pos = randomPosAwayFrom(p.pos, 160);
    game.snipers.push(new Sniper(pos.x, pos.y));
  }

  if (game.score === 10) {        // –ø–µ—Ä—à–∞ –º—ñ–Ω–∞
    const pos = randomPosAwayFrom(p.pos, 140);
    game.mines.push(new Mine(pos.x, pos.y));
  }

  if (game.score === 14) {        // –ø–µ—Ä—à–∏–π —à–≤–∏–¥–∫–∏–π –≤–æ—Ä–æ–≥
    game.enemies.push(spawnFastEnemy(p));
  }

  if (game.score === 17) {        // –¥—Ä—É–≥–∞ –º—ñ–Ω–∞
    const pos = randomPosAwayFrom(p.pos, 140);
    game.mines.push(new Mine(pos.x, pos.y));
  }

  if (game.score === 25) {        // —Ç—Ä–µ—Ç—è –º—ñ–Ω–∞
    const pos = randomPosAwayFrom(p.pos, 140);
    game.mines.push(new Mine(pos.x, pos.y));
  }

  if (game.score === 30) {        // –¥—Ä—É–≥–∞ –ø—É—à–∫–∞
    const pos = randomPosAwayFrom(p.pos, 160);
    game.snipers.push(new Sniper(pos.x, pos.y));
  }
}

// --------- –§–∞–Ω—Ç–æ–º / –•—ñ—Ç–∏ ---------
function activateGhost() {
  const p = game.player;
  p.ghost = true;
  p.ghostCooldown = 60;
  setTimeout(() => {
    p.ghost = false;
  }, p.ghostDurationMs);
}

function handleHit(source) {
  const p = game.player;
  if (p.shield > 0) {
    p.shield -= 1;
    p.pos.x += -Math.cos(p.angle) * 25;
    p.pos.y += -Math.sin(p.angle) * 25;
  } else {
    endGame(source);
  }
}

function endGame(reason) {
  if (!game || game.gameOver) return;
  game.running = false;
  game.gameOver = true;
  game.paused = false;
  stateEl.textContent = '–ö—ñ–Ω–µ—Ü—å –≥—Ä–∏';
  setTimeout(() => {
    alert(`–ì—Ä—É –∑–∞–∫—ñ–Ω—á–µ–Ω–æ (${reason}). –í–∞—à —Ä–∞—Ö—É–Ω–æ–∫: ${game.score}`);
  }, 50);
  updateUI();
}

// --------- UI ---------
function updateUI() {
  if (!game) return;
  scoreEl.textContent = game.score;
  shieldEl.textContent = game.player.shield;

  const effects = [];
  if (game.player.ghost) effects.push('–§–∞–Ω—Ç–æ–º');
  effectsEl.textContent = effects.length ? effects.join(', ') : '‚Äî';

  if (game.gameOver) {
    stateEl.textContent = '–ö—ñ–Ω–µ—Ü—å –≥—Ä–∏';
  } else if (game.paused && game.running) {
    stateEl.textContent = '–ü–∞—É–∑–∞';
  } else if (game.running) {
    stateEl.textContent = '–£ –ø—Ä–æ—Ü–µ—Å—ñ';
  } else {
    stateEl.textContent = '–ì–æ—Ç–æ–≤–æ –¥–æ —Å—Ç–∞—Ä—Ç—É';
  }
}

// --------- –ü–æ–¥—ñ—ó ---------
window.addEventListener('keydown', (e) => {
  const code = e.code;      // –Ω–µ–∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –º–æ–≤–∏ —Ä–æ–∑–∫–ª–∞–¥–∫–∏
  keys[code] = true;

  // –ü–∞—É–∑–∞ –Ω–∞ P
  if (code === 'KeyP' && game && !game.gameOver) {
    game.paused = !game.paused;
    updateUI();
    // –ù–Ü–ß–û–ì–û –Ω–µ –∑–∞–ø—É—Å–∫–∞—î–º–æ –¥–æ–¥–∞—Ç–∫–æ–≤–æ, —Ü–∏–∫–ª —É–∂–µ –∫—Ä—É—Ç–∏—Ç—å—Å—è
  }
});


window.addEventListener('keyup', (e) => {
  const code = e.code;
  keys[code] = false;
});

startBtn.addEventListener('click', startGame);
restartBtn.addEventListener('click', () => {
  resetGame();
});

resetGame();
</script>
</body>
</html>
